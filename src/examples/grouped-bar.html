<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>RespVis - Grouped Bar Chart</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta charset="UTF-8" />
    <style>
      #chart {
        width: 100%;
        height: 50vh;
        min-height: 25rem;
      }

      body {
        background-color: floralwhite;
      }
    </style>
  </head>
  <body>
    <h1>Grouped Bar Chart</h1>

    <div id="chart"></div>
    <script src="./d3/d3.v6.js"></script>
    <script src="../respvis.js"></script>
    <script type="module">
      // data
      const locations = ['Vienna', 'Rome', 'Paris', 'Berlin', 'Amsterdam'],
        years = ['2018', '2019', '2020'],
        revenues = [
          [23, 27, 29],
          [15, 13, 16],
          [43, 55, 70],
          [30, 24, 28],
          [12, 14, 18],
        ],
        keys = revenues.map((yearlyRevs, i) => yearlyRevs.map((_, j) => locations[i] + years[j])),
        maxRevenue = Math.max(...revenues.flat());

      // formatters
      var revenueFormatter = (value) => `${value}k`;

      // to toggle subcategories
      var yearToggles = [true, true, true];

      // media query for wide screens
      const wideMediaQuery = 'screen and (min-width: 40rem)';

      // scales
      const locationScale = respVis.bandScale().padding(0.1);
      const revenueScale = respVis.linearScale().domain([0, maxRevenue]).nice();

      // bars
      const barColors = respVis.GroupedBarsComponent.defaultColors;
      let filteredBarColors = barColors;
      const bars = respVis
        .groupedBars()
        .categories(locations)
        .categoryScale(locationScale)
        .values(revenues)
        .valueScale(revenueScale)
        .keys(keys)
        .onUpdateBars((selection) => respVis.updateGroupedBars(selection, filteredBarColors))
        .on('mouseover', (e, d) => hoverBar(d.categoryIndex, d.valueIndex, true))
        .on('mouseout', (e, d) => hoverBar(d.categoryIndex, d.valueIndex, false))
        .onConfigure((bars) => {
          bars.orientation(respVis.BarOrientation.Horizontal);
          if (window.matchMedia(wideMediaQuery).matches)
            bars.orientation(respVis.BarOrientation.Vertical);
        });

      // bar labels
      const barLabels = respVis
        .barLabels(bars)
        .labels(revenues.flat().map(revenueFormatter))
        .attr('pointer-events', 'none')
        .attr('font-size', 0)
        .onConfigure((barLabels) => {
          barLabels
            .widthPercent(0)
            .heightPercent(0.5)
            .attr('dominant-baseline', 'middle')
            .attr('text-anchor', 'start')
            .attr('transform', 'translate(4, 0)');
          if (window.matchMedia(wideMediaQuery).matches)
            barLabels
              .widthPercent(0.5)
              .heightPercent(1)
              .attr('dominant-baseline', 'auto')
              .attr('text-anchor', 'middle')
              .attr('transform', 'translate(0, -4)');
        });


      // legend
      const legend = respVis
        .legend(years.length)
        .attr('cursor', 'default')
        .on('mouseover', (event, data) => hoverLegendSwatch(data.childIndex, true))
        .on('mouseout', (event, data) => hoverLegendSwatch(data.childIndex, false))
        .on('click', (event, data) => clickLegendSwatch(data.childIndex))
        .layout('place-content', 'start end')
        .call((legend) =>
          legend.swatches().forEach((swatch, i) => {
            swatch.rect().attr('fill', barColors[i]);
            swatch.label().text(years[i]);
          })
        )
        .onConfigure((legend) => {
          legend.rowCount(1).columnCount(years.length);
          if (window.matchMedia(wideMediaQuery).matches)
            legend.rowCount(years.length).columnCount(1);
        });

      // left axis
      const leftAxis = respVis.leftAxis().onConfigure((axis) => {
        axis
          .ticks()
          .scale(locationScale)
          .attr('cursor', 'default')
          .onConfigureAxis((axis) => {})
          .on('mouseover', (event, data) => hoverLocationAxisTick(data.tickIndex, true))
          .on('mouseout', (event, data) => hoverLocationAxisTick(data.tickIndex, false));
        axis.title().layout('padding-right', 5).text('Locations');
        if (window.matchMedia(wideMediaQuery).matches) {
          axis
            .ticks()
            .scale(revenueScale)
            .attr('cursor', 'auto')
            .onConfigureAxis((axis) => axis.tickFormat(revenueFormatter))
            .on('mouseover', null)
            .on('mouseout', null);
          axis.title().text('Revenue');
        }
      });

      // bottom axis
      const bottomAxis = respVis.bottomAxis().onConfigure((axis) => {
        axis
          .ticks()
          .scale(revenueScale)
          .attr('cursor', 'auto')
          .onConfigureAxis((axis) => axis.tickFormat(revenueFormatter).ticks(5))
          .on('mouseover', null)
          .on('mouseout', null);
        axis.title().layout('padding-top', 5).text('Revenues');
        if (window.matchMedia(wideMediaQuery).matches) {
          axis
            .ticks()
            .scale(locationScale)
            .attr('cursor', 'default')
            .onConfigureAxis((axis) => {})
            .on('mouseover', (event, data) => hoverLocationAxisTick(data.tickIndex, true))
            .on('mouseout', (event, data) => hoverLocationAxisTick(data.tickIndex, false));
          axis.title().text('Locations');
        }
      });

      // chart
      let locationAxis, revenueAxis;
      const chart = respVis.chart();
      chart
        .root()
        .layout('padding-horizontal', 20)
        .layout('padding-top', 5)
        .onConfigure((root) => {
          root.layout('grid-template', 'auto 1fr auto / auto 1fr').layout('padding-top', 20);
          bars.layout('grid-area', '2 / 2 / 3 / 3');
          barLabels.layout('grid-area', '2 / 2 / 3 / 3');
          legend
            .layout('grid-area', '1 / 2 / 2 / 3')
            .layout('padding-bottom', 10)
            .layout('padding-left', 0);
          leftAxis.layout('grid-area', '2 / 1 / 3 / 2');
          bottomAxis.layout('grid-area', '3 / 2 / 4 / 3');
          locationAxis = leftAxis;
          revenueAxis = bottomAxis;
          if (window.matchMedia(wideMediaQuery).matches) {
            locationAxis = bottomAxis;
            revenueAxis = leftAxis;
            root.layout('grid-template', '1fr auto / auto 1fr auto');
            bars.layout('grid-area', '1 / 2 / 2 / 3');
            barLabels.layout('grid-area', '1 / 2 / 2 / 3');
            legend
              .layout('grid-area', '1 / 3 / 2 / 4')
              .layout('padding-bottom', 0)
              .layout('padding-left', 10);
            leftAxis.layout('grid-area', '1 / 1 / 2 / 2');
            bottomAxis.layout('grid-area', '2 / 2 / 3 / 3');
          }
        })
        .children([bars, barLabels, legend, leftAxis, bottomAxis]);
      chart.mount('#chart');

      function legendSwatchIndexToBarIndex(swatchIndex) {
        return yearToggles.slice(0, swatchIndex).filter((t) => t).length;
      }

      function barIndexToRevenueIndex(barIndex) {
        let lastIndex = -1;
        for (let i = 0; i <= barIndex; ++i) lastIndex = yearToggles.indexOf(true, lastIndex + 1);
        return lastIndex;
      }

      function nthOfType(index) {
        return `:nth-of-type(${index + 1})`;
      }

      function highlightBar(categoryIndex, barIndex, highlight) {
        const c = filteredBarColors[barIndex];
        bars
          .select(`.bar-group${nthOfType(categoryIndex)} rect${nthOfType(barIndex)}`)
          .attr('fill', highlight ? respVis.brighten(c, 0.5) : c);
      }

      function highlightLocationAxisTick(tickIndex, highlight) {
        locationAxis
          .select(`.tick${nthOfType(tickIndex)}`)
          .attr('text-decoration', highlight ? 'underline' : null);
      }

      function highlightLegendSwatch(swatchIndex, highlight) {
        const c = barColors[swatchIndex];
        const swatch = legend.swatches()[swatchIndex];
        swatch.rect().attr('fill', highlight ? respVis.brighten(c, 0.5) : c);
        swatch.label().attr('text-decoration', highlight ? 'underline' : null);
      }

      function disableLegendSwatch(swatchIndex, disable) {
        const c = barColors[swatchIndex];
        const swatch = legend.swatches()[swatchIndex];
        swatch.rect().attr('fill', disable ? respVis.desaturate(c, 4) : c);
        swatch.label().attr('fill', disable ? '#ababab' : null);
      }

      function showLabel(labelIndex, show) {
        barLabels.select(`text${nthOfType(labelIndex)} `).attr('font-size', show ? '1rem' : null);
      }

      function hoverBar(categoryIndex, barIndex, hover) {
        const flatBarIndex = categoryIndex * yearToggles.filter((t) => t).length + barIndex;
        highlightBar(categoryIndex, barIndex, hover);
        showLabel(flatBarIndex, hover);
        highlightLocationAxisTick(categoryIndex, hover);
        highlightLegendSwatch(barIndexToRevenueIndex(barIndex), hover);
      }

      function hoverLocationAxisTick(tickIndex, hover) {
        highlightLocationAxisTick(tickIndex, hover);
        const yearCount = yearToggles.filter((t) => t).length;
        for (let i = 0; i < yearCount; ++i) {
          const flatBarIndex = tickIndex * yearCount + i;
          highlightBar(tickIndex, i, hover);
          showLabel(flatBarIndex, hover);
        }
      }

      function hoverLegendSwatch(swatchIndex, hover) {
        if (yearToggles[swatchIndex] === false) return;

        highlightLegendSwatch(swatchIndex, hover);
        const yearCount = yearToggles.filter((t) => t).length;
        locations.forEach((location, locationIndex) => {
          let barIndex = legendSwatchIndexToBarIndex(swatchIndex);
          const flatBarIndex = locationIndex * yearCount + barIndex;
          highlightBar(locationIndex, barIndex, hover);
          showLabel(flatBarIndex, hover);
        });
      }

      function clickLegendSwatch(swatchIndex) {
        // Prevent hiding the last subcategory
        if (yearToggles.filter((t) => t).length === 1 && yearToggles[swatchIndex] === true) return;

        hoverLegendSwatch(swatchIndex, false);
        yearToggles[swatchIndex] = !yearToggles[swatchIndex];
        disableLegendSwatch(swatchIndex, !yearToggles[swatchIndex]);

        const newRevs = revenues.map((yearlyRevs) => yearlyRevs.filter((_, i) => yearToggles[i]));
        const newKeys = keys.map((yearlyKeys) => yearlyKeys.filter((_, i) => yearToggles[i]));
        bars.values(newRevs).keys(newKeys);

        filteredBarColors = barColors.filter((c, i) => yearToggles[i]);

        barLabels.labels(newRevs.flat().map(revenueFormatter));

        chart.transition();
      }
    </script>
  </body>
</html>
