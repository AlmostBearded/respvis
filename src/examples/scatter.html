<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>RespVis - Scatterplot</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta charset="UTF-8" />
    <style>
      #chart {
        width: 100%;
        height: 50vh;
        min-height: 25rem;
      }

      body {
        background-color: floralwhite;
      }
    </style>
  </head>
  <body>
    <h1>Scatterplot</h1>
    <div id="chart"></div>
    <script src="../respvis.js"></script>
    <script type="module">
      import withPaddingLayout from './components/with-padding-layout.js';
      import withLeftAxis from './components/axis/with-left-axis.js';
      import withBottomAxis from './components/axis/with-bottom-axis.js';
      import withHighlightTick from './components/axis/with-highlight-tick.js';
      import withHightlightPoint from './components/points/with-highlight-point.js';
      import data from './data/two-num.js';

      data.price = data.price.map((price) => price / 1000);

      const minArea = Math.min(...data.area),
        maxArea = Math.max(...data.area),
        areaSpan = maxArea - minArea;
      const minPrice = Math.min(...data.price),
        maxPrice = Math.max(...data.price),
        priceSpan = maxPrice - minPrice;

      const areaFormatter = (area) => `${area}ftÂ²`;
      const priceFormatter = (price) => `$${price}k`;

      const wideMediaQuery = 'screen and (min-width: 40rem)';

      // scales
      const areaScale = respVis.linearScale(),
        areaDomain = [0, maxArea + areaSpan * 0.2];
      const priceScale = respVis.linearScale(),
        priceDomain = [0, maxPrice + priceSpan * 0.2];

      let transitionTimeoutHandle,
        transitioning = false,
        resetZoomTimeoutDuration = 300,
        resetZoomTimeoutHandle;

      // points
      const pointsTransitionDuration = 1000;
      const points = withHightlightPoint(respVis.points()).config({
        categories: data.area,
        categoryScale: {
          scale: areaScale,
          domain: areaDomain,
        },
        values: data.price,
        valueScale: {
          scale: priceScale,
          domain: priceDomain,
        },
        transitionDuration: pointsTransitionDuration,
        events: {
          mouseover: (e, d) => hoverPoint(d.index, true),
          mouseout: (e, d) => hoverPoint(d.index, false),
        },
        // responsiveConfigs: {
        //   [wideMediaQuery]: {
        //     orientation: respVis.BarOrientation.Vertical,
        //     events: {
        //       mouseover: (e, d) => hoverBar(d.index, xAxis, yAxis, true),
        //       mouseout: (e, d) => hoverBar(d.index, xAxis, yAxis, false),
        //     },
        //   },
        // },
      });

      // brush
      const brush = respVis.brush().config({
        events: {
          end: (e, d) => (d.selectionRect ? zoomToRect(d.selectionRect) : resetZoom()),
        },
      });

      // bar labels
      // const barLabels = withShowLabel(respVis.barLabels()).config({
      //   attributes: {
      //     text: {
      //       'dominant-baseline': 'middle',
      //       'text-anchor': 'start',
      //       transform: 'translate(4, 0)',
      //       'pointer-events': 'none',
      //     },
      //   },
      //   bars: bars,
      //   labels: values.map(valueFormatter),
      //   horizontalPosition: respVis.HorizontalPosition.Left,
      //   verticalPosition: respVis.VerticalPosition.Center,
      //   transitionDuration: 250,
      //   responsiveConfigs: {
      //     [wideMediaQuery]: {
      //       attributes: {
      //         text: {
      //           'dominant-baseline': 'auto',
      //           'text-anchor': 'middle',
      //           transform: 'translate(0, -2)',
      //         },
      //       },
      //       horizontalPosition: respVis.HorizontalPosition.Center,
      //       verticalPosition: respVis.VerticalPosition.Top,
      //     },
      //   },
      // });

      // bottom axis
      const xAxis = withHighlightTick(withBottomAxis(respVis.group()))
        .call((axis) =>
          axis.ticks.config({
            scale: areaScale,
            ticks: 3,
            labelFormatter: areaFormatter,
            responsiveConfigs: {
              [wideMediaQuery]: {
                ticks: 6,
              },
            },
          })
        )
        .call((axis) =>
          axis.title.config({
            text: 'Area',
          })
        );

      // left axis
      const yAxis = withHighlightTick(withLeftAxis(respVis.group()))
        .call((axis) =>
          axis.ticks.config({
            scale: priceScale,
            labelFormatter: priceFormatter,
          })
        )
        .call((axis) =>
          axis.title.config({
            text: 'Price',
          })
        );

      const chart = respVis
        .chart()
        .root(
          withPaddingLayout(respVis.group()).config({
            all: 10,
            children: [
              respVis.group().config({
                attributes: { 'grid-template': '1fr auto / auto 1fr' },
                children: [
                  // brush
                  // added before points so that points can still be hovered
                  brush.config({ attributes: { 'grid-area': '1 / 2 / 2 / 3' } }),

                  // points
                  points.config({ attributes: { 'grid-area': '1 / 2 / 2 / 3' } }),

                  // bar Labels
                  // barLabels.config({ attributes: { 'grid-area': '1 / 2 / 2 / 3' } }),

                  // left axis
                  yAxis.config({ attributes: { 'grid-area': '1 / 1 / 2 / 2' } }),

                  // bottom axis
                  xAxis.config({ attributes: { 'grid-area': '2 / 2 / 3 / 3' } }),
                ],
              }),
            ],
          })
        )
        .mount('#chart');

      function hoverPoint(pointIndex, hover) {
        if (transitioning) return;
        points.highlightPoint(pointIndex, hover);
        // barLabels.showLabel(barIndex, hover);
        // categoryAxis.highlightTick(barIndex, hover);

        chart.update(false, false);
      }

      function resetZoom() {
        if (!resetZoomTimeoutHandle) {
          resetZoomTimeoutHandle = setTimeout(
            () => (resetZoomTimeoutHandle = null),
            resetZoomTimeoutDuration
          );
          return;
        }
        resetZoomTimeoutHandle = null;

        transitioning = true;
        clearTimeout(transitionTimeoutHandle);
        transitionTimeoutHandle = setTimeout(
          () => (transitioning = false),
          pointsTransitionDuration
        );

        points.clearHighlights();

        points.config({
          categoryScale: { domain: areaDomain },
          valueScale: { domain: priceDomain },
        });
        chart.update(true, true);
      }

      function zoomToRect(rect) {
        transitioning = true;
        clearTimeout(transitionTimeoutHandle);
        transitionTimeoutHandle = setTimeout(
          () => (transitioning = false),
          pointsTransitionDuration
        );

        points.clearHighlights();

        const zoomedAreaDomain = [areaScale.invert(rect.x), areaScale.invert(rect.x + rect.width)];
        const zoomedPriceDomain = [
          priceScale.invert(rect.y + rect.height),
          priceScale.invert(rect.y),
        ];
        points.config({
          categoryScale: { domain: zoomedAreaDomain },
          valueScale: { domain: zoomedPriceDomain },
        });
        chart.update(true, true);
      }
    </script>
  </body>
</html>
