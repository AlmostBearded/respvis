<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>RespVis - Scatterplot</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta charset="UTF-8" />
    <style>
      #chart {
        width: 100%;
        height: 50vh;
        min-height: 25rem;
      }

      body {
        background-color: floralwhite;
      }
    </style>
  </head>
  <body>
    <h1>Scatterplot</h1>
    <div id="chart"></div>
    <script src="../respvis.js"></script>
    <script type="module">
      import data from './data/two-num.js';

      const areas = data.area,
        prices = data.price.map((price) => price / 1000),
        minArea = Math.min(...areas),
        maxArea = Math.max(...areas),
        areaSpan = maxArea - minArea,
        areaDomain = [0, maxArea + areaSpan * 0.2],
        minPrice = Math.min(...prices),
        maxPrice = Math.max(...prices),
        priceSpan = maxPrice - minPrice,
        priceDomain = [0, maxPrice + priceSpan * 0.2],
        radiuses = prices.map((_) => 1);

      const areaFormatter = (area) => `${area}ftÂ²`;
      const priceFormatter = (price) => `$${price}k`;

      const wideMediaQuery = 'screen and (min-width: 40rem)';

      // scales
      const areaScale = respVis.linearScale().domain(areaDomain);
      const priceScale = respVis.linearScale().domain(priceDomain);
      const radiusScale = respVis.linearScale().domain([0, 1]).range([5, 5]);

      let resetZoomTimeoutDuration = 300,
        resetZoomTimeoutHandle;

      // points
      const points = respVis
        .points()
        .xValues(areas)
        .xScale(areaScale)
        .yValues(prices)
        .yScale(priceScale)
        .radiuses(radiuses)
        .radiusScale(radiusScale)
        .attr('stroke', '#000000');

      // brush
      const brush = respVis
        .brush()
        .on('end', (e, d) => (d.selectionRect ? zoomToRect(d.selectionRect) : resetZoom()));

      // y axis
      const yAxis = respVis.leftAxis();
      yAxis
        .ticks()
        .scale(priceScale)
        .onConfigureAxis((axis) => axis.tickFormat(priceFormatter));
      yAxis.title().layout('padding-right', 5).text('Price');

      // x axis
      const xAxis = respVis.bottomAxis();
      xAxis
        .ticks()
        .scale(areaScale)
        .onConfigureAxis((axis) => axis.tickFormat(areaFormatter).ticks(3));
      xAxis.title().layout('padding-top', 5).text('Area');

      // chart
      const chart = respVis.chart();
      chart
        .root()
        .layout('grid-template', '1fr auto / auto 1fr')
        .layout('padding', 20)
        .children([
          // brush before points so that points can still be hovered
          brush.layout('grid-area', '1 / 2 / 2 / 3'),
          points.layout('grid-area', '1 / 2 / 2 / 3'),
          yAxis.layout('grid-area', '1 / 1 / 2 / 2'),
          xAxis.layout('grid-area', '2 / 2 / 3 / 3'),
        ]);
      chart.mount('#chart');

      function zoomToRect(rect) {
        // clear point highlights because mouseout events might not be called during transition.
        // points.clearHighlights();

        const zoomedAreaDomain = [areaScale.invert(rect.x), areaScale.invert(rect.x + rect.width)];
        const zoomedPriceDomain = [
          priceScale.invert(rect.y + rect.height),
          priceScale.invert(rect.y),
        ];

        areaScale.domain(zoomedAreaDomain);
        priceScale.domain(zoomedPriceDomain);

        chart.transition();
      }

      function resetZoom() {
        // requires a double invocation of this function within a duration to
        // actually reset the zoom.
        //
        // this is needed because the brush selection is removed immediately after
        // zooming which would cause this function to be called and immediately reset
        // the zoom again if not for this double invocation requirement.
        if (!resetZoomTimeoutHandle) {
          resetZoomTimeoutHandle = setTimeout(
            () => (resetZoomTimeoutHandle = null),
            resetZoomTimeoutDuration
          );
          return;
        }
        resetZoomTimeoutHandle = null;

        // clear point highlights because mouseout events might not be called during transition.
        // points.clearHighlights();

        areaScale.domain(areaDomain);
        priceScale.domain(priceDomain);

        chart.transition();
      }

      // // points
      // const points = withHightlightPoint(respVis.points()).config({
      //   categories: data.area,
      //   categoryScale: {
      //     scale: areaScale,
      //     domain: areaDomain,
      //   },
      //   values: data.price,
      //   valueScale: {
      //     scale: priceScale,
      //     domain: priceDomain,
      //   },
      //   events: {
      //     mouseover: (e, d) => hoverPoint(d.index, true),
      //     mouseout: (e, d) => hoverPoint(d.index, false),
      //   },
      // });

      // // brush
      // const brush = respVis.brush().config({
      //   events: {
      //     end: (e, d) => (d.selectionRect ? zoomToRect(d.selectionRect) : resetZoom()),
      //   },
      // });

      // // bottom axis
      // const xAxis = withHighlightTick(withBottomAxis(respVis.group()))
      //   .call((axis) =>
      //     axis.ticks.config({
      //       scale: areaScale,
      //       ticks: 3,
      //       labelFormatter: areaFormatter,
      //       responsiveConfigs: {
      //         [wideMediaQuery]: {
      //           ticks: 6,
      //         },
      //       },
      //     })
      //   )
      //   .call((axis) =>
      //     axis.title.config({
      //       text: 'Area',
      //     })
      //   );

      // // left axis
      // const yAxis = withHighlightTick(withLeftAxis(respVis.group()))
      //   .call((axis) =>
      //     axis.ticks.config({
      //       scale: priceScale,
      //       labelFormatter: priceFormatter,
      //     })
      //   )
      //   .call((axis) =>
      //     axis.title.config({
      //       text: 'Price',
      //     })
      //   );

      // const chart = respVis
      //   .chart()
      //   .root(
      //     withPaddingLayout(respVis.group()).config({
      //       all: 10,
      //       children: [
      //         respVis.group().config({
      //           attributes: { 'grid-template': '1fr auto / auto 1fr' },
      //           children: [
      //             // brush
      //             // added before points so that points can still be hovered
      //             brush.config({ attributes: { 'grid-area': '1 / 2 / 2 / 3' } }),

      //             // points
      //             points.config({ attributes: { 'grid-area': '1 / 2 / 2 / 3' } }),

      //             // bar Labels
      //             // barLabels.config({ attributes: { 'grid-area': '1 / 2 / 2 / 3' } }),

      //             // left axis
      //             yAxis.config({ attributes: { 'grid-area': '1 / 1 / 2 / 2' } }),

      //             // bottom axis
      //             xAxis.config({ attributes: { 'grid-area': '2 / 2 / 3 / 3' } }),
      //           ],
      //         }),
      //       ],
      //     })
      //   )
      //   .mount('#chart');

      // function hoverPoint(pointIndex, hover) {
      //   if (points.inTransition()) return;
      //   points.highlightPoint(pointIndex, hover);
      //   // barLabels.showLabel(barIndex, hover);
      //   // categoryAxis.highlightTick(barIndex, hover);

      //   chart.update(false, false);
      // }

      // function resetZoom() {
      //   // requires a double invocation of this function within a duration to
      //   // actually reset the zoom.
      //   //
      //   // this is needed because the brush selection is removed immediately after
      //   // zooming which would cause this function to be called and immediately reset
      //   // the zoom again if not for this double invocation requirement.
      //   if (!resetZoomTimeoutHandle) {
      //     resetZoomTimeoutHandle = setTimeout(
      //       () => (resetZoomTimeoutHandle = null),
      //       resetZoomTimeoutDuration
      //     );
      //     return;
      //   }
      //   resetZoomTimeoutHandle = null;

      //   // clear point highlights because mouseout events might not be called during transition.
      //   points.clearHighlights();

      //   points.config({
      //     categoryScale: { domain: areaDomain },
      //     valueScale: { domain: priceDomain },
      //   });

      //   chart.update(true, true);
      // }

      // function zoomToRect(rect) {
      //   // clear point highlights because mouseout events might not be called during transition.
      //   points.clearHighlights();

      //   const zoomedAreaDomain = [areaScale.invert(rect.x), areaScale.invert(rect.x + rect.width)];
      //   const zoomedPriceDomain = [
      //     priceScale.invert(rect.y + rect.height),
      //     priceScale.invert(rect.y),
      //   ];
      //   points.config({
      //     categoryScale: { domain: zoomedAreaDomain },
      //     valueScale: { domain: zoomedPriceDomain },
      //   });
      //   chart.update(true, true);
      // }
    </script>
  </body>
</html>
